(*****************************************************************************
 * HOL-Z --- a shallow embedding of Z into Isabelle/HOL
 *             http://projects.brucker.ch/hol-z/
 *                                                                            
 * .sml --- 
 * This file is part of HOL-Z.
 *
 * Copyright (c) 1998-1999 University Bremen, Germany
 *               2000-2003 University Freiburg, Germany
 *               2003-2007 ETH Zurich, Switzerland
 *
 * HOL-Z is free software; you can redistribute it and/or modify it under   
 * the terms of the GNU General Public License as published by the Free       
 * Software Foundation; either version 2 of the License, or (at your option)  
 * any later version.                                                         
 *                                                                            
 * HOL-Z is distributed in the hope that it will be useful, but WITHOUT ANY 
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU General Public License for more 
 * details.                                                              
 *                                                                            
 * You should have received a copy of the GNU General Public License along    
 * with this program; if not, write to the Free Software Foundation, Inc.,    
 * 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.                  
 ******************************************************************************)
(* $Id: Z.thy 6729 2007-08-03 05:25:17Z brucker $ *)

header {* Main Theory for the HOL-Z Environment*}

theory  Z
imports ZSeqtoList 
        ZBag
        ZPure
        ZMethod

begin



section {* Proof Support: The .holz-loader (generated by ZETA) *}

ML{*

   val store_sec = ref(ZAbsy.ZSection("",[],[]));

   fun register_unit (sec as (ZAbsy.ZSection(name,_,_))) 
                     schemas axdefs conjectures thy_name thy = 
       let val zenv   = ZTheory.get_zenv thy
           val imprt'  = (thy_name::ZEnv.imports_of zenv)
           val zenv'   = ZEnv.update_Zenv_by_Imports zenv imprt'
           val zenv''  = ZEnv.update_Zenv_by_Unit zenv' (name,sec)
           val thy'     = fst(PureThy.add_thmss [(("SCHEMAS",schemas),[])]
                                                thy) 
           val thy''   = fst(PureThy.add_thmss [(("AXDEFS", axdefs),[])]
                                              thy')
           val thy'''  = fst(PureThy.add_thmss [(("CONJECTURES", conjectures),[])]
                                              thy'')
       in  ZTheory.put_zenv zenv'' thy''' end

   fun check_imports (ZAbsy.ZSection(name,importS,itemS)) thy = 
       let val thy_name = #Name(ZConversion.unitName name)
           val loaded_imports  =ZEnv.imports_of(ZTheory.get_zenv thy)
           val impnames = map(fn x=> (#Name(ZConversion.unitName x)))importS;
           (*Check if parents have already been loaded*)
       in  case filter(fn x => not(x mem loaded_imports))(impnames) of
             [] => thy_name
           | S  => error("Units: "^(concat S)^" not yet loaded!")    
       end


   fun load_holz thy_file thy  = 
       let val intext  = (File.read (Path.unpack(thy_file^".holz")))
                         handle _ => File.read(Path.unpack(
                                               "holz/"^thy_file^".holz"));
	   val sec     = (use_text Context.ml_output false 
                                   ("store_sec := "^intext);
                               !store_sec)
           val _       = ZEncoder.init();
	   val _       = ZConversion.printSec sec;
           val thy_name= check_imports sec thy;
	   val thy'    = let val (ZAbsy.ZSection(_,_,itemS)) = sec
                         in  foldl (ZConversion.convItem thy_name) 
                                   thy itemS 
                         end
           fun thm x   = get_thm thy' (Name x)
           val thy''   = register_unit
                                  sec
                                  (map thm (!ZEncoder.SCHEMANAMES)) 
                                  (map thm (!ZEncoder.AXDEFS)) 
                                  (map thm (!ZEncoder.CONJECTURES)) 
                                  thy_name 
                                  thy'
           val _       = (ZEncoder.ZENV := (ZTheory.get_zenv thy''))
       in  thy''  end;
 *}


ML{*
val load_holzP =
    OuterSyntax.command "load_holz" "load ZETA-generated .holz file"
                        OuterKeyword.thy_script
                        ((OuterParse.name)  >> (Toplevel.theory o load_holz));

val _ =  OuterSyntax.add_parsers [load_holzP];

*}

section{* Proof Support: Toplevel-Command \textbf{zlemma} *}

ML{* 
val zlemmaK = "zlemma"

val statement = OuterParse.and_list1 
                (OuterParse.opt_thm_name ":" 
                 -- Scan.repeat1 OuterParse.propp);
val general_statement = statement >> pair [] || 
                        Scan.repeat OuterParse.locale_elem_or_expr 
                        -- (OuterParse.$$$ "shows" |-- statement);

*}

ML{* 

fun smart_thm x y z w thy = 
    let
    in  case w of
        [((lemma_name,attr),[(goal,([],[]))])] => 
             let val H     = !ZEncoder.ZENV
                 val _     = (ZEncoder.ZENV:= ZTheory.get_zenv thy)
                 val cgoal = (ZEncoder.schema_read thy goal)
                 val _     = (ZEncoder.ZENV:= H )
                 val y'    = (fst y,[])
                 val w'    = [((lemma_name,[]),[(cgoal,([],[]))])]
             in  (* Locale.smart_theorem zlemmaK x y z w thy *) 
                 (Proof.theorem_i zlemmaK (K (K I)) (SOME "") y' w' o 
                  ProofContext.init) thy 
             end
       | _ => error "zlemma : wrong argument pattern !" 
    end;

val gen_zlemmaP =
  OuterSyntax.command zlemmaK ("state " ^ zlemmaK) OuterKeyword.thy_goal
    (OuterParse.opt_locale_target -- Scan.optional 
      (OuterParse.opt_thm_name ":" --|
        Scan.ahead (OuterParse.locale_keyword || OuterParse.$$$ "shows")) 
          ("", []) --
      general_statement >> (fn ((x, y), (z, w)) =>
      (Toplevel.print o Toplevel.theory_to_proof (smart_thm x y z w))));


val _ =   OuterSyntax.add_parsers [gen_zlemmaP];


*}


section {* Setup and Init of TC-sets *}

lemmas dom_infers  = dom_override_I dom_Un_I dom_insert_I1 dom_insert_I2
                     dom_dres_I dom_BagSingleton_I

lemmas type_infers = SigmaI subsetI [THEN PowI]
                     pair_rel_dom_fst pair_rel_dom

declare UNIV_I [tc_simp]
declare dom_infers [tc_simp]
declare type_infers[tc_simp]


lemmas type_infers = tfun_apply_fst tfun_apply_snd tfun_apply 
                     Dom_Partial_Fin pfun_apply_fst pfun_apply_snd pfun_apply


ML{* ZEncoder.TYPE_INFERS := (thms "type_infers") *}


section {* Legacy Bindings *}
(* renaming table ... *)
lemmas oplus_def      = override_def
lemmas oplus_I2       = overrideI2
lemmas oplus_I1       = overrideI1
lemmas oplus_CI       = overrideCI
lemmas oplus_single   = override_single
lemmas oplus_res_right= override_res_right
lemmas oplus_res_left = override_res_left
lemmas oplus_Inter    = override_inter
lemmas oplus_idem     = override_idem
lemmas oplus_mt_right = override_mt_right
lemmas oplus_mt_left  = override_mt_left
lemmas oplus_Domain   = override_Domain
lemmas oplus_comp     = override_assoc
lemmas oplus_fpfun    = override_fpfun
lemmas oplus_pfunI    = override_pfunI


lemmas oplus_apply2   = override_apply2
lemmas oplus_apply    = override_apply

lemmas oplus_apply1   = override_apply1 
lemmas oplus_non_apply= override_by_pair_apply2
lemmas oplus_by_pair_apply1 = override_by_pair_apply1
lemmas oplus_by_pair_apply2 = override_by_pair_apply2

lemmas Rel_Apply_in_total_range  = tfun_apply
lemmas partial_func_def          = pfun_def   
lemmas total_func_def            = tfun_def  

lemmas pair_mem_apply            = beta_apply_pfun 
lemmas Rel_Apply_in_Partial_Ran2 = pfun_apply
lemmas total_func_implies_Pfun   = tfun_implies_pfun

lemmas partial_fun_ran_subset    = pfun_ran_subset

lemmas partial_fun_dom_subset    = pfun_subset

lemmas dom_oplus_I = dom_override_I 

lemmas empty_pfun = empty_is_pfun 

lemmas dom_insert_apply = insert_apply 
lemmas dom_insert_apply2 = insert_apply2


(* TODO rename all stuff with dom_substr -> ndres
                              dom_restr -> dres *)

end
