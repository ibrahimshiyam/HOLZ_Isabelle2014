package zeta.tools.latex;

/** Configurations of the LaTeX concrete language. <p>
  *
  * @version $Id: LatexConfig.pizza,v 1.10 2000/07/06 09:18:24 wg Exp $
  */

import java.util.NoSuchElementException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.IOException;

import net.sf.pizzacompiler.lang.Pair;

import zeta.agl.*;
import zeta.format.*;
import zeta.util.*;
import zeta.session.*;
import zeta.content.text.*;

import zeta.content.text.Lexem.*;
import zeta.content.text.Text.*;

import zeta.content.zirp.Fixity;
import zeta.content.zirp.Fixity.*;


public class LatexConfig extends Config {

  // FIELDS

  private Set<Lexem> leftOffside = new HashSet();
  private Set<Lexem> rightOffside = new HashSet();
  private Set<String> inputs = 
    new HashSet()
      .include("\\input")
      .include("\\include");
  private Map<String, Text.ZedMarkupKind> markups = 
    new HashMap()
        .define("zed", Text.ZedMarkupKind.Unboxed)
        .define("syntax", Text.ZedMarkupKind.Unboxed)
        .define("axdef", Text.ZedMarkupKind.AxiomaticDef)
        .define("gendef", Text.ZedMarkupKind.AxiomaticDef)
        .define("schema", Text.ZedMarkupKind.Schema)
        .define("xorstate", Text.ZedMarkupKind.XorState)
        .define("andstate", Text.ZedMarkupKind.AndState)
        .define("config", Text.ZedMarkupKind.Config)
        .define("reaction", Text.ZedMarkupKind.Reaction)
        .define("transition", Text.ZedMarkupKind.Transition);
  private Set<String> classMarkups =
    new HashSet().include("class");
	

  // CONSTRUCTION

  /** */
  public LatexConfig(){
  }

  // DIRECTIVE EVALUATION

  /** */
  public void enter(Text[] texts){
    for (int i = 0; i < texts.length; i++){
      switch (texts[i]){
      case DocMarkup(_, _, Text[] subtexts):
        enter(subtexts);
        break;
      case ZedPragma(Name name, Text[] subtexts):
        String repr = name.getRepr();
        if (repr.equals("environment")){
          enterEnvironment(texts[i].locator, subtexts);
        }
      }
    }
  }
	
  private void enterEnvironment(Locator orig, Text[] texts){
    Lexem[] lexems = toLexems(texts);
    if (lexems != null &&
        lexems.length == 2 &&
        lexems[0] instanceof Lexem.Word &&
        lexems[1] instanceof Lexem.Word){
      String newName = ((Lexem.Word)lexems[0]).image;
      String oldName = ((Lexem.Word)lexems[1]).image;
      if (markups.defines(oldName)){
        markups = markups.define(newName, markups.get(oldName));
      } else if (classMarkups.contains(oldName)) {
        classMarkups.include(newName);
      } else {
        diag = diag.add(orig,
                        Diag.Category.Error,
                        "`" + oldName + "' not known as a Z environment");
      }
    } else {
      diag = diag.add(orig,
		      Diag.Category.Error,
		      "syntax error in %%environment directive");
    }
  }

  /** Convert to array of lexems, return null if not possible. */
  private static Lexem[] toLexems(Text[] texts){
    Lexem[] lexems = new Lexem[texts.length];
    for (int i = 0; i < lexems.length; i++){
      if (!(texts[i] instanceof Text.ZedToken)) return null;
      lexems[i] = ((Text.ZedToken)texts[i]).lexem;
    }
    return lexems;
  }


  // LEXICAL REPRESENTATION (STANDARD) 

  /** */
  public String getRepr(Lexem lexem){
    String string;
    switch (lexem){
      // NOTE !!!!!!!!!!!!!!!!!!!!!!!!
      // MODIFICATION REQUIRED AFTER GENLEXIS
      // case Denotation(String image): 
      //string = makeDenotation(image.toString());
      //break;

    // @@TOSTRING LaTeX,string
    // generated by genlexis:
    case Aggreg: 
      string = "\\Aggreg";
      break;
    case And: 
      string = "\\land";
      break;
    case AndState: 
      string = "\\AndState";
      break;
    case Arg: 
      string = "\\_";
      break;
    case Assoc: 
      string = "\\Assoc";
      break;
    case Await: 
      string = "\\dawait";
      break;
    case BasicState: 
      string = "\\BasicState";
      break;
    case Choice: 
      string = "\\dchoice";
      break;
    case Chop: 
      string = "\\dchop";
      break;
    case Colon: 
      string = ":";
      break;
    case Comma: 
      string = ",";
      break;
    case Compose: 
      string = "\\semi";
      break;
    case Compute: 
      string = "\\dcompute";
      break;
    case Connector: 
      string = "\\Connector";
      break;
    case Cross: 
      string = "\\cross";
      break;
    case Data: 
      string = "\\Data";
      break;
    case Defeq: 
      string = "==";
      break;
    case Defsyn: 
      string = "::=";
      break;
    case Delta: 
      string = "\\Delta";
      break;
    case Derived: 
      string = "\\Derived";
      break;
    case Dot: 
      string = ".";
      break;
    case Duration: 
      string = "\\dDuration";
      break;
    case Dyn: 
      string = "\\Dyn";
      break;
    case Else: 
      string = "\\ELSE";
      break;
    case Enrich: 
      string = "\\Enrich";
      break;
    case Everywhere: 
      string = "\\deverywhere";
      break;
    case Exists: 
      string = "\\exists";
      break;
    case Exists1: 
      string = "\\exists_1";
      break;
    case False: 
      string = "false";
      break;
    case Flow: 
      string = "\\Flow";
      break;
    case FollowedBy: 
      string = "\\dseq";
      break;
    case Forall: 
      string = "\\forall";
      break;
    case Goto: 
      string = "\\Goto";
      break;
    case Hide: 
      string = "\\hide";
      break;
    case If: 
      string = "\\IF";
      break;
    case Iff: 
      string = "\\iff";
      break;
    case Implies: 
      string = "\\implies";
      break;
    case Init: 
      string = "\\Init";
      break;
    case Internflow: 
      string = "\\InternFlow";
      break;
    case Input: 
      string = "\\Input";
      break;
    case Lambda: 
      string = "\\lambda";
      break;
    case Lbind: 
      string = "\\lblot";
      break;
    case LeftAssoc: 
      string = "\\leftassoc";
      break;
    case Lglue: 
      string = "@@lglue@@";
      break;
    case Lbrack: 
      string = "[";
      break;
    case Ldata: 
      string = "\\ldata";
      break;
    case Leadsto: 
      string = "\\dleadsto";
      break;
    case Length: 
      string = "\\dLength";
      break;
    case Let: 
      string = "\\LET";
      break;
    case Lgroup: 
      string = "{";
      break;
    case Linesep: 
      string = "\\\\";
      break;
    case ListArg: 
      string = ",,";
      break;
    case Lparenth: 
      string = "(";
      break;
    case Lset: 
      string = "\\{";
      break;
    case Lstate: 
      string = "\\dlstate";
      break;
    case Ltrans: 
      string = "\\dltrans";
      break;
    case Mid: 
      string = "|";
      break;
    case Mu: 
      string = "\\mu";
      break;
    case Not: 
      string = "\\lnot";
      break;
    case Or: 
      string = "\\lor";
      break;
    case Pipe: 
      string = "\\pipe";
      break;
    case Pre: 
      string = "\\pre";
      break;
    case Preempt: 
      string = "\\dpreempt";
      break;
    case Port: 
      string = "\\Port";
      break;
    case Power: 
      string = "\\power";
      break;
    case Property: 
      string = "\\Property";
      break;
    case Prefix: 
      string = "\\dprefix";
      break;
    case Project: 
      string = "\\project";
      break;
    case Rbind: 
      string = "\\rblot";
      break;
    case Rbrack: 
      string = "]";
      break;
    case Rdata: 
      string = "\\rdata";
      break;
    case RefState: 
      string = "\\RefState";
      break;
    case Repeat: 
      string = "\\drepeat";
      break;
    case Rglue: 
      string = "@@rglue@@";
      break;
    case Rgroup: 
      string = "}";
      break;
    case RightAssoc: 
      string = "\\rightassoc";
      break;
    case Rparenth: 
      string = ")";
      break;
    case Rset: 
      string = "\\}";
      break;
    case Rstate: 
      string = "\\drstate";
      break;
    case Rtrans: 
      string = "\\drtrans";
      break;
    case Semi: 
      string = ";";
      break;
    case Slash: 
      string = "/";
      break;
    case Somewhere: 
      string = "\\dsomewhere";
      break;
    case Spot: 
      string = "@";
      break;
    case StrokeIn: 
      string = "?";
      break;
    case StrokeOut: 
      string = "!";
      break;
    case StrokePrime: 
      string = "'";
      break;
    case Then: 
      string = "\\THEN";
      break;
    case Theta: 
      string = "\\theta";
      break;
    case To: 
      string = "\\To";
      break;
    case Trans: 
      string = "\\dtr";
      break;
    case TransLabel: 
      string = "\\tr";
      break;
    case True: 
      string = "true";
      break;
    case When: 
      string = "\\When";
      break;
    case Xi: 
      string = "\\Xi";
      break;
    case XorState: 
      string = "\\XorState";
      break;
    case Number(String image): 
      string = image.toString();
      break;
    case Denotation(String image): 
      string = image.toString();
      break;
    case StrokeIndex(String image): 
      string = image.toString();
      break;
    case Word(String image): 
      string = image.toString();
      break;
    case Keyword(Name image): 
      string = image.toString();
      break;
    case Lkeyword(Name image): 
      string = image.toString();
      break;
    case Rkeyword(Name image): 
      string = image.toString();
      break;
    case Pkeyword(Name image): 
      string = image.toString();
      break;
    case SimpleName(Name image): 
      string = image.toString();
      break;
    case MacroArg(String image): 
      string = image.toString();
      break;

    // @@ENDTOSTRING
    }
    return string;
  }

  private String makeDenotation(String s){
    int l = s.length();
    StringBuffer res = new StringBuffer("\\ZD{");
    for (int i = 0; i < l; i++){
      char c = s.charAt(i);
      switch (c){
      case '{': case '}': case '\\': case '"':
	res.append('\\');
	res.append(c);
	break;
      case '\n':
	res.append("\\n");
	break;
      case '\r':
	res.append("\\r");
	break;
      case '\t':
	res.append("\\t");
	break;
      case '\f':
	res.append("\\f");
	break;
      case '\b':
	res.append("\\b");
	break;
      default:
	res.append(c);
      }
    }
    res.append('}');
    return res.toString();
  }


  /** */
  public boolean isLeftOffside(Lexem lexem){
    if (leftOffside.contains(lexem)){
      return true;
    } else {
      boolean res;
      switch (lexem){
      // @@LEFTOFFSIDE LaTeX,res
      // generated by genlexis:
      case Aggreg: 
        res = false;
        break;
      case And: 
        res = true;
        break;
      case AndState: 
        res = false;
        break;
      case Arg: 
        res = false;
        break;
      case Assoc: 
        res = false;
        break;
      case Await: 
        res = false;
        break;
      case BasicState: 
        res = false;
        break;
      case Choice: 
        res = true;
        break;
      case Chop: 
        res = true;
        break;
      case Colon: 
        res = true;
        break;
      case Comma: 
        res = true;
        break;
      case Compose: 
        res = true;
        break;
      case Compute: 
        res = true;
        break;
      case Connector: 
        res = false;
        break;
      case Cross: 
        res = true;
        break;
      case Data: 
        res = false;
        break;
      case Defeq: 
        res = true;
        break;
      case Defsyn: 
        res = true;
        break;
      case Delta: 
        res = false;
        break;
      case Derived: 
        res = false;
        break;
      case Dot: 
        res = true;
        break;
      case Duration: 
        res = false;
        break;
      case Dyn: 
        res = false;
        break;
      case Else: 
        res = true;
        break;
      case Enrich: 
        res = false;
        break;
      case Everywhere: 
        res = false;
        break;
      case Exists: 
        res = false;
        break;
      case Exists1: 
        res = false;
        break;
      case False: 
        res = false;
        break;
      case Flow: 
        res = false;
        break;
      case FollowedBy: 
        res = true;
        break;
      case Forall: 
        res = false;
        break;
      case Goto: 
        res = true;
        break;
      case Hide: 
        res = true;
        break;
      case If: 
        res = false;
        break;
      case Iff: 
        res = true;
        break;
      case Implies: 
        res = true;
        break;
      case Init: 
        res = false;
        break;
      case Internflow: 
        res = false;
        break;
      case Input: 
        res = false;
        break;
      case Lambda: 
        res = false;
        break;
      case Lbind: 
        res = false;
        break;
      case LeftAssoc: 
        res = false;
        break;
      case Lglue: 
        res = false;
        break;
      case Lbrack: 
        res = false;
        break;
      case Ldata: 
        res = false;
        break;
      case Leadsto: 
        res = true;
        break;
      case Length: 
        res = false;
        break;
      case Let: 
        res = false;
        break;
      case Lgroup: 
        res = false;
        break;
      case Linesep: 
        res = false;
        break;
      case ListArg: 
        res = false;
        break;
      case Lparenth: 
        res = false;
        break;
      case Lset: 
        res = false;
        break;
      case Lstate: 
        res = false;
        break;
      case Ltrans: 
        res = false;
        break;
      case Mid: 
        res = true;
        break;
      case Mu: 
        res = false;
        break;
      case Not: 
        res = false;
        break;
      case Or: 
        res = true;
        break;
      case Pipe: 
        res = true;
        break;
      case Pre: 
        res = false;
        break;
      case Preempt: 
        res = true;
        break;
      case Port: 
        res = false;
        break;
      case Power: 
        res = false;
        break;
      case Property: 
        res = false;
        break;
      case Prefix: 
        res = false;
        break;
      case Project: 
        res = true;
        break;
      case Rbind: 
        res = true;
        break;
      case Rbrack: 
        res = true;
        break;
      case Rdata: 
        res = true;
        break;
      case RefState: 
        res = false;
        break;
      case Repeat: 
        res = false;
        break;
      case Rglue: 
        res = true;
        break;
      case Rgroup: 
        res = false;
        break;
      case RightAssoc: 
        res = false;
        break;
      case Rparenth: 
        res = true;
        break;
      case Rset: 
        res = true;
        break;
      case Rstate: 
        res = true;
        break;
      case Rtrans: 
        res = true;
        break;
      case Semi: 
        res = true;
        break;
      case Slash: 
        res = true;
        break;
      case Somewhere: 
        res = false;
        break;
      case Spot: 
        res = true;
        break;
      case StrokeIn: 
        res = false;
        break;
      case StrokeOut: 
        res = false;
        break;
      case StrokePrime: 
        res = false;
        break;
      case Then: 
        res = true;
        break;
      case Theta: 
        res = false;
        break;
      case To: 
        res = true;
        break;
      case Trans: 
        res = true;
        break;
      case TransLabel: 
        res = true;
        break;
      case True: 
        res = false;
        break;
      case When: 
        res = true;
        break;
      case Xi: 
        res = false;
        break;
      case XorState: 
        res = false;
        break;
      case Number(String image): 
        res = false;
        break;
      case Denotation(String image): 
        res = false;
        break;
      case StrokeIndex(String image): 
        res = false;
        break;
      case Word(String image): 
        res = false;
        break;
      case Keyword(Name image): 
        res = false;
        break;
      case Lkeyword(Name image): 
        res = false;
        break;
      case Rkeyword(Name image): 
        res = false;
        break;
      case Pkeyword(Name image): 
        res = false;
        break;
      case SimpleName(Name image): 
        res = false;
        break;
      case MacroArg(String image): 
        res = false;
        break;

      // @@ENDLEFTOFFSIDE
      }
      return res;
    }
  }

  /** */
  public boolean isRightOffside(Lexem lexem){
    if (rightOffside.contains(lexem)){
      return true;
    } else {
      boolean res;
      switch (lexem){
      // @@RIGHTOFFSIDE LaTeX,res
      // generated by genlexis:
      case Aggreg: 
        res = true;
        break;
      case And: 
        res = true;
        break;
      case AndState: 
        res = false;
        break;
      case Arg: 
        res = false;
        break;
      case Assoc: 
        res = true;
        break;
      case Await: 
        res = true;
        break;
      case BasicState: 
        res = false;
        break;
      case Choice: 
        res = true;
        break;
      case Chop: 
        res = true;
        break;
      case Colon: 
        res = true;
        break;
      case Comma: 
        res = true;
        break;
      case Compose: 
        res = true;
        break;
      case Compute: 
        res = true;
        break;
      case Connector: 
        res = false;
        break;
      case Cross: 
        res = true;
        break;
      case Data: 
        res = false;
        break;
      case Defeq: 
        res = true;
        break;
      case Defsyn: 
        res = true;
        break;
      case Delta: 
        res = true;
        break;
      case Derived: 
        res = true;
        break;
      case Dot: 
        res = true;
        break;
      case Duration: 
        res = false;
        break;
      case Dyn: 
        res = true;
        break;
      case Else: 
        res = true;
        break;
      case Enrich: 
        res = true;
        break;
      case Everywhere: 
        res = true;
        break;
      case Exists: 
        res = true;
        break;
      case Exists1: 
        res = true;
        break;
      case False: 
        res = false;
        break;
      case Flow: 
        res = true;
        break;
      case FollowedBy: 
        res = true;
        break;
      case Forall: 
        res = true;
        break;
      case Goto: 
        res = true;
        break;
      case Hide: 
        res = true;
        break;
      case If: 
        res = true;
        break;
      case Iff: 
        res = true;
        break;
      case Implies: 
        res = true;
        break;
      case Init: 
        res = true;
        break;
      case Internflow: 
        res = false;
        break;
      case Input: 
        res = true;
        break;
      case Lambda: 
        res = true;
        break;
      case Lbind: 
        res = true;
        break;
      case LeftAssoc: 
        res = false;
        break;
      case Lglue: 
        res = false;
        break;
      case Lbrack: 
        res = true;
        break;
      case Ldata: 
        res = true;
        break;
      case Leadsto: 
        res = true;
        break;
      case Length: 
        res = false;
        break;
      case Let: 
        res = true;
        break;
      case Lgroup: 
        res = false;
        break;
      case Linesep: 
        res = false;
        break;
      case ListArg: 
        res = false;
        break;
      case Lparenth: 
        res = true;
        break;
      case Lset: 
        res = true;
        break;
      case Lstate: 
        res = true;
        break;
      case Ltrans: 
        res = true;
        break;
      case Mid: 
        res = true;
        break;
      case Mu: 
        res = true;
        break;
      case Not: 
        res = true;
        break;
      case Or: 
        res = true;
        break;
      case Pipe: 
        res = true;
        break;
      case Pre: 
        res = true;
        break;
      case Preempt: 
        res = true;
        break;
      case Port: 
        res = true;
        break;
      case Power: 
        res = true;
        break;
      case Property: 
        res = true;
        break;
      case Prefix: 
        res = true;
        break;
      case Project: 
        res = true;
        break;
      case Rbind: 
        res = false;
        break;
      case Rbrack: 
        res = false;
        break;
      case Rdata: 
        res = false;
        break;
      case RefState: 
        res = false;
        break;
      case Repeat: 
        res = true;
        break;
      case Rglue: 
        res = false;
        break;
      case Rgroup: 
        res = false;
        break;
      case RightAssoc: 
        res = false;
        break;
      case Rparenth: 
        res = false;
        break;
      case Rset: 
        res = false;
        break;
      case Rstate: 
        res = false;
        break;
      case Rtrans: 
        res = false;
        break;
      case Semi: 
        res = true;
        break;
      case Slash: 
        res = true;
        break;
      case Somewhere: 
        res = true;
        break;
      case Spot: 
        res = true;
        break;
      case StrokeIn: 
        res = false;
        break;
      case StrokeOut: 
        res = false;
        break;
      case StrokePrime: 
        res = false;
        break;
      case Then: 
        res = true;
        break;
      case Theta: 
        res = true;
        break;
      case To: 
        res = true;
        break;
      case Trans: 
        res = true;
        break;
      case TransLabel: 
        res = true;
        break;
      case True: 
        res = false;
        break;
      case When: 
        res = true;
        break;
      case Xi: 
        res = true;
        break;
      case XorState: 
        res = false;
        break;
      case Number(String image): 
        res = false;
        break;
      case Denotation(String image): 
        res = false;
        break;
      case StrokeIndex(String image): 
        res = false;
        break;
      case Word(String image): 
        res = false;
        break;
      case Keyword(Name image): 
        res = false;
        break;
      case Lkeyword(Name image): 
        res = false;
        break;
      case Rkeyword(Name image): 
        res = false;
        break;
      case Pkeyword(Name image): 
        res = false;
        break;
      case SimpleName(Name image): 
        res = false;
        break;
      case MacroArg(String image): 
        res = false;
        break;

      // @@ENDRIGHTOFFSIDE
      }
      return res;
    }
  }

  // LEXICAL REPRESENTATION (LaTeX SPECIFIC)

  /** Translate environment name to a paragraph markup kind. Return null if
    * the environment name does not represent a Z markup. */
  public Text.ZedMarkupKind getMarkupKind(String name){
    try {
      return markups.get(name);
    }
    catch (NoSuchElementException e){
      return null;
    }
  }

  /** Test whether the given environment name is a class markup name
   */
  public boolean isClassMarkup(String name){
    return classMarkups.contains(name);
  }

  /** Test whether given LaTeX command name represents an \input-like
    * command. */
  public boolean isInputCommand(String name){
    return inputs.contains(name);
  }

  // PRETTYPRINTING

  private boolean isLeftBracket(Lexem lexem) {
    switch (lexem) {
      case Lbrack:
      case Lparenth:
      case Lset:
      case Lgroup:
        return true;
      default:
        return false;
    }
  }

  private boolean isRightBracket(Lexem lexem) {
    switch (lexem) {
      // case Rbag:
      case Rbrack:
      case Rparenth:
      case Rset:
      case Rgroup:
        return true;
      default:
        return false;
    }
  }

  private boolean isStroke(Lexem lexem) {
    switch (lexem) {
      case StrokeIn:
      case StrokeOut:
      case StrokePrime:
        return true;
      case StrokeIndex(String image):
        return true;
      default:
        return false;
    }
  }

  private boolean isPunctuation(Lexem lexem) {
    switch (lexem) {
      case Dot:
      case Comma:
      case Colon:
      case Semi:
        return true;
      default:
        return false;
    }
  }

  private boolean isIdentifier(Text text) {
    switch (text) {
      case ZedToken(Lexem lexem):
        if (isPunctuation(lexem) ||
            isLeftBracket(lexem) ||
            isRightBracket(lexem) ||
            isStroke(lexem))
          return false;
        switch (lexem) {
          case Word(String word):
            return true;
          default:
            String word = getRepr(lexem);
            if (word.length() > 0 && word.charAt(0) == '\\')
              return true;
        }
        break;
      case Literal(String word):
        return true;
    }
    return false;
  }

  private boolean isGraphem(Text text) {
    String word;

    if (isIdentifier(text))
      return false;
    switch (text) {
      case ZedToken(Lexem lexem):
        if (isLeftBracket(lexem) ||
            isRightBracket(lexem) ||
            isPunctuation(lexem))
          return false;
        word = getRepr(lexem);
        break;
      case Literal(String w):
        word = w;
        break;
      default:
        return false;
    }
    return 
      (word.length() > 0 &&
       !(Character.isLetterOrDigit(word.charAt(0)) || 
         Character.isLetterOrDigit(word.charAt(word.length()-1))));
  }

  /** */
  public boolean needSpaceBetween(Text left, Text right) {
    // FIXME -- additional conditions?
    left:
    switch (left) {
      case ZedToken(Lexem lexem):
        // no space after opening bracket
        if (isLeftBracket(lexem))
          break;
        // space after closing bracket before identifiers
        if (isRightBracket(lexem) && isIdentifier(right))
          return true;
        switch (lexem) {
          case Dot:
          case Comma:
            break left;
          case Spot:
          case Mid:
          case Colon:
          case Semi:
          case True:
          case False:
	  case Data:		// NO EFFECT??? Robert
	  case Port:
	  case Property:
            return true;
          default:
            if (isGraphem(left))
              return true;
        }
        break;
    }
    right:
    switch (right) {
      case ZedToken(Lexem lexem):
        if (isPunctuation(lexem))
          break;
        if (isStroke(lexem))
          break;
        if (isRightBracket(lexem))
          break;
        if (isLeftBracket(lexem) && isIdentifier(left))
          return true;
        switch (lexem) {
          case Spot:
          case Mid:
          case True:
          case False:
            return true;
          default:
            if (isGraphem(right))
              return true;
        }
        break;
    }
    if (isIdentifier(left) && isIdentifier(right))
      return true;
    return false;
  }

  protected boolean needBreakBetween(Text left, Text right) {
    switch (left) {
      /*
      case ZedToken(Linesep):
        return true;
      */
      case ZedMarkup(Text.ZedMarkupKind kind, Text[] hd, Text[] dc, Text[] pr):
        return true;
    }
    switch (right) {
      case ZedMarkup(Text.ZedMarkupKind kind, Text[] hd, Text[] dc, Text[] pr):
        return true;
    }
    return false;
  }

  // PRETTYPRINTING

  protected Format prettyModelInclusion(Name name) {
    return
      Format.append(Format.literal("\\IncludeModel"),
                    Format.list(Format.literal("{"),
                                Format.space,
                                Format.literal("}"), 
                                new Format[] {
                                  Format.literal(name.toString()) 
                                }));
  }

  protected Format prettyZedSection(Name name,
                                    Name[] parents,
                                    Text[] subtexts) {
    Seq<Format> buffer = new BufferSeq();
    Seq<Format> b = new BufferSeq();

    buffer = new BufferSeq();   
    buffer = buffer.append(Format.literal("\\zsection"));
    if (parents.length > 0) {
      buffer = buffer.append(Format.list(Format.literal("["),
                                         Format.literal(","),
                                         Format.literal("]"),
                                         parents));
    }
    buffer = buffer.append(Format.literal("{"));
    buffer = buffer.append(Format.literal(name.toString()));
    buffer = buffer.append(Format.literal("}"));
    b = b.append(Format.append(buffer.toArray(Format.class)));
    b = b.append(Format.brk);
    b = b.append(prettySubtexts(subtexts,FormatKind.Beneath(0)));
    // b = b.append(Format.literal("\\endzsection"));
    return Format.beneath(b.toArray(Format.class));
  }

  protected Format prettyZedClass(Name name,
                                  Name[] parents,
                                  Name[] formals,
                                  Text[] subtexts) {
    Seq<Format> buffer = new BufferSeq();
    Seq<Format> b = new BufferSeq();

    buffer = buffer.append(Format.literal("\\begin{class}"));
    if (parents.length > 0) {
      buffer =
        buffer.append(Format.list(Format.literal("["),
                                  Format.literal(","),
                                  Format.literal("]"),
                                  parents));
    }
    buffer = buffer.append(Format.literal("{"));
    buffer = buffer.append(Format.literal(name.toString()));
    if (formals.length > 0) {
      buffer =
        buffer.append(Format.list(Format.literal("["),
                                  Format.literal(","),
                                  Format.literal("]"),
                                  formals));
    }
    buffer = buffer.append(Format.literal("}"));
    b = b.append(Format.line(buffer.toArray(Format.class)));
    b = b.append(prettySubtexts(subtexts,FormatKind.Beneath(2)));
    b = b.append(Format.literal("\\end{class}"));
    return Format.beneath(b.toArray(Format.class));
  }

  private int operandPrio(Component c) {
    switch (c) {
      case Operand(int prio):
        return prio;
      default:
        return 0;
    }
  }

  protected Format prettyZedFixity(Fixity fixity) {
    Seq<Format> buffer = new BufferSeq();
    Format fmt;

    switch (fixity) {
      case Fixity(int prio,
                  boolean isGeneric,
                  Component[] components):
        for (int i = 0; i < components.length; i++) {
          switch (components[i]) {
            case Keyword(Name name):
              buffer = buffer.append(Format.literal(name.toString()));
              break;
            case Operand(int p):
              buffer = buffer.append(Format.literal("\\_"));
              break;
            case OperandList(Name left, Name right):
              buffer = buffer.append(Format.literal(left.toString()));
              buffer = buffer.append(Format.literal(",,"));
              buffer = buffer.append(Format.literal(right.toString()));
              break;
          }
        }
        fmt = Format.list(Format.literal("("),
                          Format.space,
                          Format.literal(")"),
                          buffer.toArray(Format.class));
        if (prio <= Fixity.relationPrio) {
          return
            Format.list(Format.literal("\\zrelation{"),
                        Format.empty,
                        Format.literal("}"),
                        new Format[] { fmt });
        } else if (isGeneric) {
          return
            Format.list(Format.literal("\\zgeneric{"),
                        Format.space,
                        Format.literal("}"),
                        new Format[] { Format.literal(prio+""), fmt });
        } else { // function
          if (components.length == 3 &&
              components[0] instanceof Fixity.Component.Operand &&
              components[1] instanceof Fixity.Component.Keyword &&
              components[2] instanceof Fixity.Component.Operand) {
            // infix
            if (operandPrio(components[0]) < operandPrio(components[2])) {
              // leftassoc
              return
                Format.list(Format.literal("\\zfunction{"),
                            Format.space,
                            Format.literal("}"),
                            new Format[] { Format.literal(prio+""),
                                           Format.literal("\\leftassoc"),
                                           fmt });

	    } else if (operandPrio(components[0]) >
                       operandPrio(components[2])) {
              // rightassoc
              return
                Format.list(Format.literal("\\zfunction{"),
                            Format.space,
                            Format.literal("}"),
                            new Format[] { Format.literal(prio+""),
                                           Format.literal("\\rightassoc"),
                                           fmt });
            }
	  }
	  return
	    Format.list(Format.literal("\\zfunction{"),
			Format.space,
			Format.literal("}"),
			new Format[] { Format.literal(prio+""), fmt });
	}
    }
  }

  protected Format prettyZedMacro(Name name, int argc, Lexem[] def) {
    StringBuffer s = new StringBuffer(0);

    s = s.append("%%macro "+name+" "+argc);
    for (int i = 0; i < def.length; i++)
      s = s.append(" "+getRepr(def[i]));
    return Format.literal(s.toString());
  }

  protected Format prettyZedPragma(Name name, Text[] subtexts) {
    Seq<Format> buffer = new BufferSeq();

    buffer = buffer.append(Format.literal("%%"));
    buffer = buffer.append(Format.literal(name.toString()));
    buffer = buffer.append(Format.space);
    buffer = buffer.append(prettySubtexts(subtexts,FormatKind.Append(0)));
    // buffer = buffer.append(Format.brk);
    return Format.append(buffer.toArray(Format.class));
  }

  /** return the zed-environment for each markup kind */
  private String getZedEnvironment(Text.ZedMarkupKind kind) {
    switch (kind) {
      case Text.ZedMarkupKind.Unboxed:      return "zed";
      case Text.ZedMarkupKind.Schema:       return "schema";
      case Text.ZedMarkupKind.AxiomaticDef: return "axdef";
      case Text.ZedMarkupKind.Config:       return "config";
      case Text.ZedMarkupKind.Reaction:     return "reaction";
      case Text.ZedMarkupKind.Transition:   return "trans";
      case Text.ZedMarkupKind.XorState:     return "xorstate";
      case Text.ZedMarkupKind.AndState:     return "andstate";
    }
  }

  /** implementation of abstract Config method */
  protected Format prettyZedMarkup(Text.ZedMarkupKind kind,
                                   Text[] header,
                                   Text[] decls,
                                   Text[] props) {
    Seq<Format> buffer;
    Seq<Format> b = new BufferSeq();

    String env = getZedEnvironment(kind);
    int l = header.length;

    buffer = new BufferSeq();   
    buffer = buffer.append(Format.literal("\\begin"));
    buffer = buffer.append(Format.literal("{"));
    buffer = buffer.append(Format.literal(env));
    buffer = buffer.append(Format.literal("}"));
    if (l > 0) {
      buffer = buffer.append(Format.literal("{"));
      buffer = buffer.append(prettySubtexts(header,FormatKind.Append(0)));
      buffer = buffer.append(Format.literal("}"));
    }
    b = b.append(Format.line(buffer.toArray(Format.class)));
    b = b.append(prettySubtexts(decls,FormatKind.Beneath(2)));
    if (props.length > 0) {
      b = b.append(Format.literal("\\where"));
      b = b.append(prettySubtexts(props,FormatKind.Beneath(2)));
    }
    buffer = new BufferSeq();
    buffer = buffer.append(Format.literal("\\end"));
    buffer = buffer.append(Format.literal("{"));
    buffer = buffer.append(Format.literal(env));
    buffer = buffer.append(Format.literal("}"));
    b = b.append(Format.line(buffer.toArray(Format.class)));
    return Format.beneath(b.toArray(Format.class));
  }

  // FORMATTING

  /** */
  public Format toFormat(FormatInfo info){
    return Format.describe("LaTeX config",
			   new String[]{"leftOffside", "rightOffside",
					 "inputs", "markups"},
			   new Format[]{Format.buildFormat(leftOffside),
					 Format.buildFormat(rightOffside),
					 Format.buildFormat(inputs),
					 Format.buildFormat(markups)});
  }
  

  // SERIALIZATION

  private void writeObject(ObjectOutputStream s)
  throws IOException {
    s.writeObject(leftOffside.toArray(Lexem.class));
    s.writeObject(rightOffside.toArray(Lexem.class));
    s.writeObject(inputs.toArray(String.class));
    String[] names = new String[markups.size()];
    ZedMarkupKind[] kinds = new ZedMarkupKind[names.length];
    int i = 0;
    markups.apply(
      fun (Pair<String,ZedMarkupKind> p)->void {
        names[i] = p.fst; kinds[i] = p.snd; i++;
      }
    );
    s.writeObject(names);
    s.writeObject(kinds);
  }
    
  private void readObject(ObjectInputStream s)
  throws IOException, ClassNotFoundException {
    leftOffside = HashSet.from(new ArraySeq((Lexem[])s.readObject()));
    rightOffside = HashSet.from(new ArraySeq((Lexem[])s.readObject()));
    inputs = HashSet.from(new ArraySeq((String[])s.readObject()));
    String[] names = (String[])s.readObject();
    ZedMarkupKind[] kinds = (ZedMarkupKind[])s.readObject();
    markups = new HashMap()
                   .defineAll(new ArraySeq(names), new ArraySeq(kinds));
  }

}
