package zeta.tools.zparser;

/** The token manager used for the parser. <p>
  *
  * @version $Id: TextTokenManager.pizza,v 1.6 2000/07/06 09:18:24 wg Exp $
  */

import zeta.util.*;
import zeta.session.*;
import zeta.content.text.*;

class TextTokenManager implements TokenManager, ItemParserConstants {

  private Text.ZedToken[] tokens;
  private int pos;
  private Locator lastLocator;

  /** Create a new token manager. 
    */
  TextTokenManager(Text.ZedToken[] tokens){ 
    // System.out.println("token manager tokens:");
    // System.out.println(zeta.format.Format.buildFormat(tokens).toString());
    this.tokens = tokens;
    pos = 0;
    lastLocator = null;
  }

  /** Get next token (the parsers entry). */
  public Token getNextToken(){
    if (pos >= tokens.length){
      TextToken t = new TextToken();
      t.kind = EOF;
      t.image = tokenImage[EOF];
      t.lexem = null; 
      if (lastLocator != null){
	t.locator = lastLocator; // FIXME: end label?
      }
      return t;
    } else {
      Text.ZedToken textToken = tokens[pos++];
      Lexem lexem = textToken.lexem;
      int tokKind;
      switch (lexem){
      // @@TOTOKENKIND tokKind,tokImage,Z,MSZ,DZ,LEX,INTERN
      // generated by genlexis:
      case Aggreg: 
        tokKind = AGGREG;
        break;
      case And: 
        tokKind = AND;
        break;
      case AndState: 
        tokKind = ANDSTATE;
        break;
      case Arg: 
        tokKind = ARG;
        break;
      case Assoc: 
        tokKind = ASSOC;
        break;
      case Await: 
        tokKind = AWAIT;
        break;
      case BasicState: 
        tokKind = BASICSTATE;
        break;
      case Choice: 
        tokKind = CHOICE;
        break;
      case Chop: 
        tokKind = CHOP;
        break;
      case Colon: 
        tokKind = COLON;
        break;
      case Comma: 
        tokKind = COMMA;
        break;
      case Compose: 
        tokKind = COMPOSE;
        break;
      case Compute: 
        tokKind = COMPUTE;
        break;
      case Connector: 
        tokKind = CONNECTOR;
        break;
      case Cross: 
        tokKind = CROSS;
        break;
      case Data: 
        tokKind = DATA;
        break;
      case Defeq: 
        tokKind = DEFEQ;
        break;
      case Defsyn: 
        tokKind = DEFSYN;
        break;
      case Delta: 
        tokKind = DELTA;
        break;
      case Derived: 
        tokKind = DERIVED;
        break;
      case Dot: 
        tokKind = DOT;
        break;
      case Duration: 
        tokKind = DURATION;
        break;
      case Dyn: 
        tokKind = DYN;
        break;
      case Else: 
        tokKind = ELSE;
        break;
      case Enrich: 
        tokKind = ENRICH;
        break;
      case Everywhere: 
        tokKind = EVERYWHERE;
        break;
      case Exists: 
        tokKind = EXISTS;
        break;
      case Exists1: 
        tokKind = EXISTS1;
        break;
      case False: 
        tokKind = FALSE;
        break;
      case Flow: 
        tokKind = FLOW;
        break;
      case FollowedBy: 
        tokKind = FOLLOWEDBY;
        break;
      case Forall: 
        tokKind = FORALL;
        break;
      case Goto: 
        tokKind = GOTO;
        break;
      case Hide: 
        tokKind = HIDE;
        break;
      case If: 
        tokKind = IF;
        break;
      case Iff: 
        tokKind = IFF;
        break;
      case Implies: 
        tokKind = IMPLIES;
        break;
      case Init: 
        tokKind = INIT;
        break;
      case Internflow: 
        tokKind = INTERNFLOW;
        break;
      case Input: 
        tokKind = INPUT;
        break;
      case Lambda: 
        tokKind = LAMBDA;
        break;
      case Lbind: 
        tokKind = LBIND;
        break;
      case LeftAssoc: 
        tokKind = LEFTASSOC;
        break;
      case Lglue: 
        tokKind = LGLUE;
        break;
      case Lbrack: 
        tokKind = LBRACK;
        break;
      case Ldata: 
        tokKind = LDATA;
        break;
      case Leadsto: 
        tokKind = LEADSTO;
        break;
      case Length: 
        tokKind = LENGTH;
        break;
      case Let: 
        tokKind = LET;
        break;
      case Lgroup: 
        tokKind = LGROUP;
        break;
      case Linesep: 
        tokKind = LINESEP;
        break;
      case ListArg: 
        tokKind = LISTARG;
        break;
      case Lparenth: 
        tokKind = LPARENTH;
        break;
      case Lset: 
        tokKind = LSET;
        break;
      case Lstate: 
        tokKind = LSTATE;
        break;
      case Ltrans: 
        tokKind = LTRANS;
        break;
      case Mid: 
        tokKind = MID;
        break;
      case Mu: 
        tokKind = MU;
        break;
      case Not: 
        tokKind = NOT;
        break;
      case Or: 
        tokKind = OR;
        break;
      case Pipe: 
        tokKind = PIPE;
        break;
      case Pre: 
        tokKind = PRE;
        break;
      case Preempt: 
        tokKind = PREEMPT;
        break;
      case Port: 
        tokKind = PORT;
        break;
      case Power: 
        tokKind = POWER;
        break;
      case Property: 
        tokKind = PROPERTY;
        break;
      case Prefix: 
        tokKind = PREFIX;
        break;
      case Project: 
        tokKind = PROJECT;
        break;
      case Rbind: 
        tokKind = RBIND;
        break;
      case Rbrack: 
        tokKind = RBRACK;
        break;
      case Rdata: 
        tokKind = RDATA;
        break;
      case RefState: 
        tokKind = REFSTATE;
        break;
      case Repeat: 
        tokKind = REPEAT;
        break;
      case Rglue: 
        tokKind = RGLUE;
        break;
      case Rgroup: 
        tokKind = RGROUP;
        break;
      case RightAssoc: 
        tokKind = RIGHTASSOC;
        break;
      case Rparenth: 
        tokKind = RPARENTH;
        break;
      case Rset: 
        tokKind = RSET;
        break;
      case Rstate: 
        tokKind = RSTATE;
        break;
      case Rtrans: 
        tokKind = RTRANS;
        break;
      case Semi: 
        tokKind = SEMI;
        break;
      case Slash: 
        tokKind = SLASH;
        break;
      case Somewhere: 
        tokKind = SOMEWHERE;
        break;
      case Spot: 
        tokKind = SPOT;
        break;
      case StrokeIn: 
        tokKind = STROKEIN;
        break;
      case StrokeOut: 
        tokKind = STROKEOUT;
        break;
      case StrokePrime: 
        tokKind = STROKEPRIME;
        break;
      case Then: 
        tokKind = THEN;
        break;
      case Theta: 
        tokKind = THETA;
        break;
      case To: 
        tokKind = TO;
        break;
      case Trans: 
        tokKind = TRANS;
        break;
      case TransLabel: 
        tokKind = TRANSLABEL;
        break;
      case True: 
        tokKind = TRUE;
        break;
      case When: 
        tokKind = WHEN;
        break;
      case Xi: 
        tokKind = XI;
        break;
      case XorState: 
        tokKind = XORSTATE;
        break;
      case Number(String image): 
        tokKind = NUMBER;
        break;
      case Denotation(String image): 
        tokKind = DENOTATION;
        break;
      case StrokeIndex(String image): 
        tokKind = STROKEINDEX;
        break;
      case Word(String image): 
        tokKind = WORD;
        break;
      case Keyword(Name image): 
        tokKind = KEYWORD;
        break;
      case Lkeyword(Name image): 
        tokKind = LKEYWORD;
        break;
      case Rkeyword(Name image): 
        tokKind = RKEYWORD;
        break;
      case Pkeyword(Name image): 
        tokKind = PKEYWORD;
        break;
      case SimpleName(Name image): 
        tokKind = SIMPLENAME;
        break;
      case MacroArg(String image): 
        tokKind = MACROARG;
        break;

      // @@ENDTOTOKENKIND
	// default:
		// throw FatalError.unexpectedCase();
      }
      TextToken t = new TextToken();
      t.kind = tokKind;
      t.image = tokenImage[tokKind];
      t.lexem = lexem;
      t.locator = lastLocator = textToken.locator;
      return t;
    }
  }
      
}

