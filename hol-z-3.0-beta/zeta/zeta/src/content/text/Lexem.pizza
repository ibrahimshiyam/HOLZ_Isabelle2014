package zeta.content.text;

/** 
 * Class of Z lexems.  
 *
 * @version $Id: Lexem.pizza,v 1.6 2000/07/06 09:18:24 wg Exp $
 * @author Wolfgang Grieskamp (wg@cs.tu-berlin.de)
 */

import zeta.util.Name;
import zeta.util.Term;
import zeta.format.*;

public class Lexem extends Term {

  // @@CASES
  // generated by genlexis:
  /** [MSZ] Aggregation keyword (configurations). */
  public case Aggreg;
  /** [Z] Logical conjunction. */
  public case And;
  /** [MSZ] And state declaration. */
  public case AndState;
  /** [Z] Argument placeholder. */
  public case Arg;
  /** [MSZ] Association keyword (configurations). */
  public case Assoc;
  /** [DZ] Await operator. */
  public case Await;
  /** [MSZ] Basic state declaration. */
  public case BasicState;
  /** [DZ] Choice operator. */
  public case Choice;
  /** [DZ] Chop operator. */
  public case Chop;
  /** [Z] Colon. */
  public case Colon;
  /** [Z] Comma. */
  public case Comma;
  /** [Z] Sequential composition. */
  public case Compose;
  /** [DZ] Computation. */
  public case Compute;
  /** [MSZ] Connector declaration (statecharts). */
  public case Connector;
  /** [Z] Cartesian product. */
  public case Cross;
  /** [MSZ] Data role. */
  public case Data;
  /** [Z] Definining equality. */
  public case Defeq;
  /** [Z] Syntax (free type) definition equality. */
  public case Defsyn;
  /** [Z] Delta (schema operator). */
  public case Delta;
  /** [MSZ] Derived attribute. */
  public case Derived;
  /** [Z] Selection dot. */
  public case Dot;
  /** [DZ] Duration predicate. */
  public case Duration;
  /** [DZ] Dynamic text. */
  public case Dyn;
  /** [Z] Else */
  public case Else;
  /** [MSZ] Enrichment. */
  public case Enrich;
  /** [DZ] Temporal everywhere. */
  public case Everywhere;
  /** [Z] Existential quantor. */
  public case Exists;
  /** [Z] Unique existential quantor. */
  public case Exists1;
  /** [Z] False. */
  public case False;
  /** [MSZ] Flow Declaration (?). */
  public case Flow;
  /** [DZ] Overlapping chop operator. */
  public case FollowedBy;
  /** [Z] Universal quantor. */
  public case Forall;
  /** [MSZ] Goto state. */
  public case Goto;
  /** [Z] Schema hiding. */
  public case Hide;
  /** [Z] If. */
  public case If;
  /** [Z] If and only if. */
  public case Iff;
  /** [Z] Implies. */
  public case Implies;
  /** [MSZ] Init role. */
  public case Init;
  /** [MSZ] Internal flow declaration (?). */
  public case Internflow;
  /** [MSZ] Input attribute. */
  public case Input;
  /** [Z] Lambda. */
  public case Lambda;
  /** [Z] Left binding bracket. */
  public case Lbind;
  /** [Z] Left associtivity indicator. */
  public case LeftAssoc;
  /** [INTERN] Left glueing bracket (for pretty printing). */
  public case Lglue;
  /** [Z] Left square bracket. */
  public case Lbrack;
  /** [Z] Left chevron bracket (free type). */
  public case Ldata;
  /** [DZ] Temporal leadsto. */
  public case Leadsto;
  /** [DZ] Length predicate. */
  public case Length;
  /** [Z] Let abbreviation. */
  public case Let;
  /** [LEX] Left macro parameter group bracket. */
  public case Lgroup;
  /** [Z] Line separator. */
  public case Linesep;
  /** [Z] List argument place holder. */
  public case ListArg;
  /** [Z] Left parenth. */
  public case Lparenth;
  /** [Z] Left set bracket. */
  public case Lset;
  /** [DZ] Left state predicate. */
  public case Lstate;
  /** [DZ] Left transition predicate. */
  public case Ltrans;
  /** [Z] Mid. */
  public case Mid;
  /** [Z] Mu. */
  public case Mu;
  /** [Z] Logical not */
  public case Not;
  /** [Z] Logical or. */
  public case Or;
  /** [Z] Schema piping. */
  public case Pipe;
  /** [Z] Schema precondition. */
  public case Pre;
  /** [DZ] Preemption. */
  public case Preempt;
  /** [MSZ] Port role. */
  public case Port;
  /** [Z] Power set. */
  public case Power;
  /** [MSZ] Property role. */
  public case Property;
  /** [DZ] Prefix predicate. */
  public case Prefix;
  /** [Z] Schema projection. */
  public case Project;
  /** [Z] Right binding bracket. */
  public case Rbind;
  /** [Z] Right square bracket. */
  public case Rbrack;
  /** [Z] Right data bracket (free type). */
  public case Rdata;
  /** [MSZ] Referred state declaration. */
  public case RefState;
  /** [DZ] Repetition predicate */
  public case Repeat;
  /** [INTERN] Right glueing bracket. */
  public case Rglue;
  /** [LEX] Right macro parameter group bracket. */
  public case Rgroup;
  /** [Z] Right associtivity indicator. */
  public case RightAssoc;
  /** [Z] Right parenth bracket. */
  public case Rparenth;
  /** [Z] Right set bracket. */
  public case Rset;
  /** [DZ] Right state predicate. */
  public case Rstate;
  /** [DZ] Right transition predicate. */
  public case Rtrans;
  /** [Z] Semicolon. */
  public case Semi;
  /** [Z] Slash (renaming). */
  public case Slash;
  /** [DZ] Somewhere predicate. */
  public case Somewhere;
  /** [Z] Spot. */
  public case Spot;
  /** [Z] Input stroke. */
  public case StrokeIn;
  /** [Z] Output stroke. */
  public case StrokeOut;
  /** [Z] Prime stroke. */
  public case StrokePrime;
  /** [Z] Then. */
  public case Then;
  /** [Z] Theta. */
  public case Theta;
  /** [MSZ] Flow direction (?). */
  public case To;
  /** [DZ] Transition. */
  public case Trans;
  /** [MSZ] Transition label. */
  public case TransLabel;
  /** [Z] True. */
  public case True;
  /** [MSZ] When condition. */
  public case When;
  /** [Z] Xi. */
  public case Xi;
  /** [MSZ] Xor state declaration. */
  public case XorState;
  /** [Z] Number. */
  public case Number(String image);
  /** [Z] Denotation. */
  public case Denotation(String image);
  /** [Z] Index stroke. */
  public case StrokeIndex(String image);
  /** [Z] Word (basic identifier). */
  public case Word(String image);
  /** [INTERN] Keyword (component of fixity). */
  public case Keyword(Name image);
  /** [INTERN] Left open keyword (component of fixity). */
  public case Lkeyword(Name image);
  /** [INTERN] Right close keyword (component of fixity). */
  public case Rkeyword(Name image);
  /** [INTERN] Predicate keyword (component of fixity). */
  public case Pkeyword(Name image);
  /** [INTERN] Simple name. */
  public case SimpleName(Name image);
  /** [LEX] Argument placeholder of a macro. */
  public case MacroArg(String image);

  // @@ENDCASES

  /** Give string image of lexem. */
  public String toString(){
    String string;
    switch (this){
    // @@TOIMAGE string
    // generated by genlexis:
    case Aggreg: 
      string = "<AGGREG>";
      break;
    case And: 
      string = "<AND>";
      break;
    case AndState: 
      string = "<ANDSTATE>";
      break;
    case Arg: 
      string = "<ARG>";
      break;
    case Assoc: 
      string = "<ASSOC>";
      break;
    case Await: 
      string = "<AWAIT>";
      break;
    case BasicState: 
      string = "<BASICSTATE>";
      break;
    case Choice: 
      string = "<CHOICE>";
      break;
    case Chop: 
      string = "<CHOP>";
      break;
    case Colon: 
      string = "<COLON>";
      break;
    case Comma: 
      string = "<COMMA>";
      break;
    case Compose: 
      string = "<COMPOSE>";
      break;
    case Compute: 
      string = "<COMPUTE>";
      break;
    case Connector: 
      string = "<CONNECTOR>";
      break;
    case Cross: 
      string = "<CROSS>";
      break;
    case Data: 
      string = "<DATA>";
      break;
    case Defeq: 
      string = "<DEFEQ>";
      break;
    case Defsyn: 
      string = "<DEFSYN>";
      break;
    case Delta: 
      string = "<DELTA>";
      break;
    case Derived: 
      string = "<DERIVED>";
      break;
    case Dot: 
      string = "<DOT>";
      break;
    case Duration: 
      string = "<DURATION>";
      break;
    case Dyn: 
      string = "<DYN>";
      break;
    case Else: 
      string = "<ELSE>";
      break;
    case Enrich: 
      string = "<ENRICH>";
      break;
    case Everywhere: 
      string = "<EVERYWHERE>";
      break;
    case Exists: 
      string = "<EXISTS>";
      break;
    case Exists1: 
      string = "<EXISTS1>";
      break;
    case False: 
      string = "<FALSE>";
      break;
    case Flow: 
      string = "<FLOW>";
      break;
    case FollowedBy: 
      string = "<FOLLOWEDBY>";
      break;
    case Forall: 
      string = "<FORALL>";
      break;
    case Goto: 
      string = "<GOTO>";
      break;
    case Hide: 
      string = "<HIDE>";
      break;
    case If: 
      string = "<IF>";
      break;
    case Iff: 
      string = "<IFF>";
      break;
    case Implies: 
      string = "<IMPLIES>";
      break;
    case Init: 
      string = "<INIT>";
      break;
    case Internflow: 
      string = "<INTERNFLOW>";
      break;
    case Input: 
      string = "<INPUT>";
      break;
    case Lambda: 
      string = "<LAMBDA>";
      break;
    case Lbind: 
      string = "<LBIND>";
      break;
    case LeftAssoc: 
      string = "<LEFTASSOC>";
      break;
    case Lglue: 
      string = "<LGLUE>";
      break;
    case Lbrack: 
      string = "<LBRACK>";
      break;
    case Ldata: 
      string = "<LDATA>";
      break;
    case Leadsto: 
      string = "<LEADSTO>";
      break;
    case Length: 
      string = "<LENGTH>";
      break;
    case Let: 
      string = "<LET>";
      break;
    case Lgroup: 
      string = "<LGROUP>";
      break;
    case Linesep: 
      string = "<LINESEP>";
      break;
    case ListArg: 
      string = "<LISTARG>";
      break;
    case Lparenth: 
      string = "<LPARENTH>";
      break;
    case Lset: 
      string = "<LSET>";
      break;
    case Lstate: 
      string = "<LSTATE>";
      break;
    case Ltrans: 
      string = "<LTRANS>";
      break;
    case Mid: 
      string = "<MID>";
      break;
    case Mu: 
      string = "<MU>";
      break;
    case Not: 
      string = "<NOT>";
      break;
    case Or: 
      string = "<OR>";
      break;
    case Pipe: 
      string = "<PIPE>";
      break;
    case Pre: 
      string = "<PRE>";
      break;
    case Preempt: 
      string = "<PREEMPT>";
      break;
    case Port: 
      string = "<PORT>";
      break;
    case Power: 
      string = "<POWER>";
      break;
    case Property: 
      string = "<PROPERTY>";
      break;
    case Prefix: 
      string = "<PREFIX>";
      break;
    case Project: 
      string = "<PROJECT>";
      break;
    case Rbind: 
      string = "<RBIND>";
      break;
    case Rbrack: 
      string = "<RBRACK>";
      break;
    case Rdata: 
      string = "<RDATA>";
      break;
    case RefState: 
      string = "<REFSTATE>";
      break;
    case Repeat: 
      string = "<REPEAT>";
      break;
    case Rglue: 
      string = "<RGLUE>";
      break;
    case Rgroup: 
      string = "<RGROUP>";
      break;
    case RightAssoc: 
      string = "<RIGHTASSOC>";
      break;
    case Rparenth: 
      string = "<RPARENTH>";
      break;
    case Rset: 
      string = "<RSET>";
      break;
    case Rstate: 
      string = "<RSTATE>";
      break;
    case Rtrans: 
      string = "<RTRANS>";
      break;
    case Semi: 
      string = "<SEMI>";
      break;
    case Slash: 
      string = "<SLASH>";
      break;
    case Somewhere: 
      string = "<SOMEWHERE>";
      break;
    case Spot: 
      string = "<SPOT>";
      break;
    case StrokeIn: 
      string = "<STROKEIN>";
      break;
    case StrokeOut: 
      string = "<STROKEOUT>";
      break;
    case StrokePrime: 
      string = "<STROKEPRIME>";
      break;
    case Then: 
      string = "<THEN>";
      break;
    case Theta: 
      string = "<THETA>";
      break;
    case To: 
      string = "<TO>";
      break;
    case Trans: 
      string = "<TRANS>";
      break;
    case TransLabel: 
      string = "<TRANSLABEL>";
      break;
    case True: 
      string = "<TRUE>";
      break;
    case When: 
      string = "<WHEN>";
      break;
    case Xi: 
      string = "<XI>";
      break;
    case XorState: 
      string = "<XORSTATE>";
      break;
    case Number(String image): 
      string = image.toString();
      break;
    case Denotation(String image): 
      string = image.toString();
      break;
    case StrokeIndex(String image): 
      string = image.toString();
      break;
    case Word(String image): 
      string = image.toString();
      break;
    case Keyword(Name image): 
      string = image.toString();
      break;
    case Lkeyword(Name image): 
      string = image.toString();
      break;
    case Rkeyword(Name image): 
      string = image.toString();
      break;
    case Pkeyword(Name image): 
      string = image.toString();
      break;
    case SimpleName(Name image): 
      string = image.toString();
      break;
    case MacroArg(String image): 
      string = image.toString();
      break;

    // @@ENDTOIMAGE
    }
    return string;
  }

  /**
   * Return format for lexem.
   */
  public Format toFormat(FormatInfo info){
    return Format.literal(toString());
  }

}
